[
    {
        "id": "neon-grid-calibration",
        "title": "Neon Grid Calibration",
        "difficulty": "Easy",
        "category": "Arrays",
        "description": "The Neo-City power grid requires immediate calibration. You are given an array of energy readouts `powerLevels`. The system is stable only if no two adjacent sectors have the exact same power level.\n\nReturn `true` if the grid is stable (no adjacent duplicates), or `false` if the grid is at risk of an overload.",
        "examples": [
            {
                "input": "powerLevels = [1, 2, 3, 1, 4]",
                "output": "true"
            },
            {
                "input": "powerLevels = [1, 2, 2, 4]",
                "output": "false"
            }
        ],
        "constraints": [
            "1 <= powerLevels.length <= 10^5",
            "0 <= powerLevels[i] <= 9"
        ],
        "starterCode": "/**\n * @param {number[]} powerLevels\n * @return {boolean}\n */\nvar isGridStable = function(powerLevels) {\n    \n};",
        "testCases": [
            {
                "input": [
                    [
                        1,
                        2,
                        3,
                        1,
                        4
                    ]
                ],
                "expected": true
            },
            {
                "input": [
                    [
                        1,
                        2,
                        2,
                        4
                    ]
                ],
                "expected": false
            },
            {
                "input": [
                    [
                        5
                    ]
                ],
                "expected": true
            },
            {
                "input": [
                    [
                        9,
                        9
                    ]
                ],
                "expected": false
            }
        ],
        "functionName": "isGridStable"
    },
    {
        "id": "decrypt-the-datapad",
        "title": "Decrypt the Datapad",
        "difficulty": "Easy",
        "category": "Strings",
        "description": "A rogue AI has encrypted a sensitive datapad byte-sequence by shifting every character by exactly 1 position in the ASCII table (e.g., 'a' becomes 'b', 'A' becomes 'B'). \n\nGiven the encrypted string `cipher`, write an algorithm to decrypt it by shifting every character back by 1. For simplicity, assume characters wrap around only within readable ASCII ranges (32 to 126).",
        "examples": [
            {
                "input": "cipher = \"Ifmmp\"",
                "output": "\"Hello\""
            }
        ],
        "constraints": [
            "1 <= cipher.length <= 10^4",
            "cipher consists of printable ASCII characters."
        ],
        "starterCode": "/**\n * @param {string} cipher\n * @return {string}\n */\nvar decryptDatapad = function(cipher) {\n    \n};",
        "testCases": [
            {
                "input": [
                    "Ifmmp"
                ],
                "expected": "Hello"
            },
            {
                "input": [
                    "!Bc"
                ],
                "expected": " AB"
            },
            {
                "input": [
                    "123"
                ],
                "expected": "012"
            }
        ],
        "functionName": "decryptDatapad"
    },
    {
        "id": "rogue-agent-intercept",
        "title": "Rogue Agent Intercept",
        "difficulty": "Medium",
        "category": "Two Pointers",
        "description": "A rogue agent is moving through a linear databank represented by an array `sectors`. The agent is moving right, while your tracker is moving left from the end. \n\nYou are given an integer array `sectors` and a target value `rogueSignature`. Find if there are ANY two distinct sectors `i` and `j` where `sectors[i] + sectors[j] === rogueSignature`.\n\n*Note*: The `sectors` array is **strictly sorted** in ascending order.",
        "examples": [
            {
                "input": "sectors = [-5, -2, 0, 3, 8], rogueSignature = 1",
                "output": "true"
            }
        ],
        "constraints": [
            "2 <= sectors.length <= 10^5",
            "sectors is sorted in non-decreasing order.",
            "-10^9 <= sectors[i] <= 10^9"
        ],
        "starterCode": "/**\n * @param {number[]} sectors\n * @param {number} rogueSignature\n * @return {boolean}\n */\nvar interceptAgent = function(sectors, rogueSignature) {\n    \n};",
        "testCases": [
            {
                "input": [
                    [
                        -5,
                        -2,
                        0,
                        3,
                        8
                    ],
                    1
                ],
                "expected": true
            },
            {
                "input": [
                    [
                        1,
                        2,
                        4,
                        6
                    ],
                    10
                ],
                "expected": true
            },
            {
                "input": [
                    [
                        1,
                        2,
                        3
                    ],
                    10
                ],
                "expected": false
            }
        ],
        "functionName": "interceptAgent"
    },
    {
        "id": "optimize-server-load",
        "title": "Optimize Server Load",
        "difficulty": "Medium",
        "category": "Hash Table",
        "description": "The mainframe is receiving connection requests from various IP addresses. To prevent a DDoS attack, we need to find the **most frequent** connecting IP.\n\nYou are given an array of string IP addresses `requests`. Return the string IP that appears the most times. If there is a tie, return any of the most frequent IPs.",
        "examples": [
            {
                "input": "requests = [\"192.168.1.1\", \"10.0.0.1\", \"192.168.1.1\"]",
                "output": "\"192.168.1.1\""
            }
        ],
        "constraints": [
            "1 <= requests.length <= 10^4",
            "requests[i] is a valid IPv4 address format string."
        ],
        "starterCode": "/**\n * @param {string[]} requests\n * @return {string}\n */\nvar findMostFrequentIP = function(requests) {\n    \n};",
        "testCases": [
            {
                "input": [
                    [
                        "192.168.1.1",
                        "10.0.0.1",
                        "192.168.1.1"
                    ]
                ],
                "expected": "192.168.1.1"
            },
            {
                "input": [
                    [
                        "1.1.1.1",
                        "2.2.2.2",
                        "1.1.1.1",
                        "3.3.3.3",
                        "2.2.2.2",
                        "2.2.2.2"
                    ]
                ],
                "expected": "2.2.2.2"
            }
        ],
        "functionName": "findMostFrequentIP"
    },
    {
        "id": "cybernetic-arm-calibration",
        "title": "Cybernetic Arm Calibration",
        "difficulty": "Hard",
        "category": "Dynamic Programming",
        "description": "A military-grade cybernetic arm requires exact kinetic calibration. You are given an array `powerCells` where `powerCells[i]` represents energy. The arm can only absorb energy by skipping at least one cell between absorptions (to prevent thermal overload).\n\nFind the **maximum total energy** the arm can absorb without triggering an overload.",
        "examples": [
            {
                "input": "powerCells = [5, 1, 2, 10, 6, 2]",
                "output": "17"
            }
        ],
        "constraints": [
            "1 <= powerCells.length <= 10^5",
            "0 <= powerCells[i] <= 1000"
        ],
        "starterCode": "/**\n * @param {number[]} powerCells\n * @return {number}\n */\nvar calibrateArm = function(powerCells) {\n    // Hint: Think about calculating the max at each step without picking adjacent cells\n};",
        "testCases": [
            {
                "input": [
                    [
                        5,
                        1,
                        2,
                        10,
                        6,
                        2
                    ]
                ],
                "expected": 17
            },
            {
                "input": [
                    [
                        2,
                        7,
                        9,
                        3,
                        1
                    ]
                ],
                "expected": 12
            },
            {
                "input": [
                    [
                        100
                    ]
                ],
                "expected": 100
            }
        ],
        "functionName": "calibrateArm"
    },
    {
        "id": "breach-the-mainframe",
        "title": "Breach the Mainframe",
        "difficulty": "Hard",
        "category": "Graphs / BFS",
        "description": "You are a runner trying to map the shortest path through a corporate mainframe's firewall grid.\n\nThe grid is represented by an `m x n` matrix map where `0` is an open node and `1` is a firewall barrier. You start at the top-left `(0, 0)` and must reach the bottom-right `(m-1, n-1)`. You can move up, down, left, or right.\n\nReturn the **shortest path length** (number of steps). If it is impossible to reach the end, return `-1`.",
        "examples": [
            {
                "input": "grid = [[0,0,0],[1,1,0],[0,0,0]]",
                "output": "4"
            }
        ],
        "constraints": [
            "1 <= m, n <= 100",
            "grid[i][j] is 0 or 1",
            "grid[0][0] == 0"
        ],
        "starterCode": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar shortestPath = function(grid) {\n    \n};",
        "testCases": [
            {
                "input": [
                    [
                        [
                            0,
                            0,
                            0
                        ],
                        [
                            1,
                            1,
                            0
                        ],
                        [
                            0,
                            0,
                            0
                        ]
                    ]
                ],
                "expected": 4
            },
            {
                "input": [
                    [
                        [
                            0,
                            1
                        ],
                        [
                            1,
                            0
                        ]
                    ]
                ],
                "expected": -1
            },
            {
                "input": [
                    [
                        [
                            0,
                            0,
                            0
                        ],
                        [
                            0,
                            1,
                            0
                        ],
                        [
                            0,
                            0,
                            0
                        ]
                    ]
                ],
                "expected": 4
            }
        ],
        "functionName": "shortestPath"
    }
]